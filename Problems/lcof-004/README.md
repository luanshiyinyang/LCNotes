## 题目描述

在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数`target`，判断数组中是否含有该整数`target`。

```
现有矩阵 matrix 如下：

[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
给定 target = 5，返回 true。
给定 target = 20，返回 false。
```

## 题解思路

这题最直接的思路就是暴力搜索，遍历数组的每一行每一列，若找到目标元素则返回True，若遍历完整个数组依然没有找到目标元素，那么返回False。显然这个解法的时间复杂度为$O(mn)$，空间复杂度为$O(1)$。

上面的暴力法最大的问题就是没有利用到给定的二维数组时有序的这一特性，其实如果从左下角元素沿着对角线看，不难发现这个二维数组有点类似于二叉搜索树的性质。**更直白地讲，对角线上地元素其实就是它所在行和所在列所有元素地中间值，有了这个中间值的概念，我们其实就可以想到利用二分查找来优化搜索的速度了。**

具体而言，从左下角的元素位置开始遍历元素，然后用下面的思路来处理：

- 若目标值`target`比中间值大，则下标右移（因为本列最大的则为中间值，本列其余元素无需访问）；
- 若目标值`target`比中间值小，则下标上移（因为本行最小的则为中间值，本行其余元素无需访问）；
- 若目标值`target`等于中间值，则找到目标，返回True。
  
当访问完整个数组都没有return出去，则直接返回False；此外，若输入矩阵为空，直接返回False。

这种解法的时间复杂度为$O(n+m)$，因为访问到的下标的行最多减少$n$次，列最多增加$m$次，因此循环体最多执行$n + m$次。至于空间复杂度依然是$O(1)$。

完整代码如下，也可见[solve.py](./solve.py)。

```python
class Solution:
    def findNumberIn2DArray(self, matrix: List[List[int]], target: int) -> bool:
        if matrix == []:
            return False
        row, column = len(matrix), len(matrix[0])
        i, j = row - 1, 0
        while i >=0 and j < column:
            if matrix[i][j] > target:
                i -= 1
            elif matrix[i][j] < target:
                j += 1
            else:
                return True
        return False
```

