## 题目描述

如果字符串 `s` 中**不存在**两个不同字符**频次**相同的情况，就称`s`是 **优质字符串** 。

给你一个字符串 `s`，返回使 `s` 成为 优质字符串 需要删除的**最小**字符数。

字符串中字符的**频次**是该字符在字符串中的出现次数。例如，在字符串`"aab"`中，`'a'`的频次是 2，而`'b'`的频次是 1 。

**示例 1：**
```
输入：s = "aab"
输出：0
解释：s 已经是优质字符串。
```

**示例 2：**
```
输入：s = "aaabbbcc"
输出：2
解释：可以删除两个 'b' , 得到优质字符串 "aaabcc" 。
另一种方式是删除一个 'b' 和一个 'c' ，得到优质字符串 "aaabbc" 。
```

**示例 3：**
```
输入：s = "ceabaacb"
输出：2
解释：可以删除两个 'c' 得到优质字符串 "eabaab" 。
注意，只需要关注结果字符串中仍然存在的字符。（即，频次为 0 的字符会忽略不计。）
```

## 题解思路

这题的思路比较难想。先统计出每个字符的出现频次，然后逐个处理统计结果数组，对于数组中的一个元素，如果其他位置出现了这个元素，就将其频次减去1并将最终的操作数加上1（最多消除到频次为0）。

有很多解法都提到对于统计频次数组需要先排序，**这里其实不是必要的**。具体的证明这里不提，以一个直观的例子来说明的话，例如频次数组为未排序的`3 2 1 4 4`和排好序的`4 4 3 2 1`，前者需要将第一个4减到0，操作数为4，后者则需要将第一个4减到0，操作数也是4，所以答案只需要在乎去重自减时，减少的个数，而不用在意顺序。

上述解法的代码如下，也可见于[solve.py](./solve.py)。

```python
class Solution:
    def minDeletions(self, s: str) -> int:
        stats = list(collections.Counter(s).values())
        res = 0
        for i in range(len(stats)):
            while stats[i] > 0 and stats[i] in stats[:i] + stats[i+1:]:
                stats[i] -= 1
                res += 1
        return res
```

上述解法的时间复杂度都是$O(N)$，而空间复杂度为常数级别的$O(1)$，其中$N$为字符串长度。