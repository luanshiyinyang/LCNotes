## 题目描述

0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。

**示例1：**
```
输入: n = 5, m = 3
输出: 3
```

**示例2：**
```
输入: n = 10, m = 17
输出: 2
```

## 题解思路

这道题很容易想到模拟，但是这种方法会超时，但是为什么会超时呢？我们首先考虑如何模拟，最方便的，**我们考虑一个长度为n的链表，节点值就是顺序索引，我们每轮删除第m个节点直到链表长度为1**。 可以发现啊，这个思路需要循环n-1次，每轮在链表中找到第m个节点又需要m次访问，因此总体复杂度为$O(nm)$，而题目给出的n和m最大为$10^5$和$10^6$，显然这是不可接受的。

这道题其实是著名的“**约瑟夫环**”问题，它可以使用动态规划来解决。

我们不妨记这个问题的解为`F(n, m)`，那么我们直觉上会察觉到这包含一个递推关系，我们有：
- `0, 1, 2, 3, ... n-1`的环的解为`F(n, m)`;
- `0, 1, 2, 3, ..., n-2`的环的解为`F(n-1, m)`;
- 以此类推。

我们不妨先看`F(n, m)`的求解。在第一轮，我们需要删除环中第m个数字，得到一个长度为n-1的环，由于m可能大于n，因此实际上这一轮删除的数字是`(m-1)%n`（因为从0开始），第二轮的环则从`m%n`开始，我们记这个`m%n`为t，则第二轮的环为：

`t, t+1, t+2, ... 0, 1, ..., t-2`

这是一个`F(n-1, m)`的问题，且如果将其当作新问题进行对应会发现这个新的环i位置的值其实就是第一轮删除元素后剩余环的第`(i+t)%n`位置的值。

因此，如果我们知道了`F(n-1, m)`问题的解，可以通过上面的变换得到`F(n, m)`的解，也就是下式。

$$
\begin{aligned}
F(n, m) &=(F(n-1, m)+t) \% n \\
&=(F(n-1, m)+m \% n) \% n \\
&=(F(n-1, m)+m) \% n
\end{aligned}
$$

因此，我们可以利用动态规划一步步向上求解，因为我们有`F(1, m)=0`的初值。

具体的代码如下，也可见于[solve.py](./solve.py)。

```python
class Solution:
    def lastRemaining(self, n: int, m: int) -> int:
        x = 0
        for i in range(2, n+1):
            x = (x + m) % i
        return x 
```

显然上述解法的时间复杂度为$O(n)$，空间复杂度为$O(1)$。
