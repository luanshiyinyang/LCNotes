## 题目描述

实现 $pow(x, n)$，即计算 $x$ 的 $n$ 次幂函数（即，$x^n$）。不得使用库函数，同时不需要考虑大数问题。

**示例1：**
```
输入：x = 2.00000, n = 10
输出：1024.00000
```

**示例2：**
```
输入：x = 2.10000, n = 3
输出：9.26100
```

**示例3：**
```
输入：x = 2.00000, n = -2
输出：0.25000
解释：2-2 = 1/22 = 1/4 = 0.25
```

## 题解思路

如果我们采用经典的乘法，也就是求$x^n$就将$n$个$x$乘起来，那么时间复杂度则为$O(n)$。

这道题其实是快速幂算法的典型例题，可以将时间复杂度降低至$O(log_2^n)$，下面，我们从二进制的角度来理解这个算法。（**快速幂算法是非常高效的一种算法，在其他题目中也有涉及，关于其二进制解释或者二分法解释务必了解至少一种。**）

> 举个例子，对于求$x^{11}$，若采用11次乘法，那么时间复杂度为$O(n)$。但是我们可以将其拆分为$x^{11} = x^{2^3 + 2^1 + 2^0} = x^{2^3} \times x^{2^1} \times x^{2^0}$，此时只计算了三次乘积，复杂度降低为$O(logn)$。

对于任何一个十进制正整数$n$，其二进制都可以表示为$b_m\cdots b_3b_2b_1$（其中$b_i$表示二进制的某位值，它非0即1，$i \in [1,m]$），则有：
- 二进制转十进制：$n=1b_1+2b_2+4b_3+\cdots 2^{m-1}b_m$;
- 幂的二进制展开：$x^n = x^{1b_1+2b_2+4b_3+\cdots 2^{m-1}b_m} = x^{1b_1}x^{2b_2}x^{4b_3}\cdots x^{2^{m-1}b_m}$；

因此，求解$x^n$的问题转化为求解下面两个问题：
- 计算$x^1,x^2, x^4\cdots x^{2^{m-1}}$的值，这并不难实现，只要不断循环赋值$x=x^2$即可；
- 获取各个二进制位的值$b_1,b_2, b_3, \cdots, b_m$，该操作的实现可以通过和1进行逐位与运算来实现，具体为循环下面的操作：
  - `n&1`（与操作），判断n的二进制的最后一位是否是1；
  - `n>>1`（移位操作），通过n右移一位来实现类似删除最后一位。

综上，应用上述操作可在循环中依次计算$x^{2^0b_1}$，$x^{2^1b_2}$...$x^{2^{m-1}b_m}$的值，并将他们累乘。
- 当$b_i=0$时，$x^{2^{i-1}b_i} = 1$；
- 当$b_i=1$时，$x^{2^{i-1}b_i} = x^{2^{i-1}}$。

在实现时，需要注意，若是n为负数，我们可以令$x^n = (\frac{1}{x})^{-n}$来转化。

上述思路的代码实现如下，也可见于[solve.py](./solve.py)。

```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if x == 0:
            return 0
        res = 1
        if n < 0:
            x, n = 1/x, -n
        while n:
            if n & 1:
                res *= x
            x *= x
            n >>= 1
        return res
```

上述代码的时间复杂度显然为$O(log_2^n)$。