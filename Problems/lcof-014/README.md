## 题目描述

给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为` k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] `可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

**示例1：**
```
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1
```
**示例2：**
```
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
```

补充：这题和主站题库的第343题是相同的，只是换了个说法而已，原题如下。
```
给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。
```

## 题解思路

这种最优解的问题很容易想到动态规划，但是这题是否适合动态规划呢？我们首先来尝试寻找一个递推关系。

首先，一个正整数n，若n>=2，那么可以将其拆分为两个正整数的和，假定k是第一个数，n-k是第二个数。对n-k，我们可以继续拆分也可以不拆分，但是我们知道，一个正整数的最大乘积一定依赖于比它小的正整数的最大乘积，**因此我们可以考虑采用动态规划来求解**。

我们不妨定义维护的最优解数组dp，其中dp\[i\]表示将正整数i拆分为至少两个数的和之后，这些拆分出来的数的最大乘积。

### 状态初始化

显然，0不是正整数，1也不能拆分为两个正整数的和，因此有`dp[0]=dp[1]=0`。

### 状态转移方程

显然，当i>=2时，假设对i拆分出的第一个正整数为a（必有`1<=a<i`），那么此时存在两种情况：

1. 将i拆分为a和i-a的和，i-a不再进行拆分，此时乘积为a*(i-a)；
2. 将i拆分为a和i-a的和，i-a继续拆分，此时乘积为a*dp[i-a]。

故有，若a固定，状态转移式子为`dp[i] = max(a*(i-a), a*dp[i-a])`，而由于a的范围是1到i-1，因此遍历a得到最大的dp[a]即可，所以总的状态转移方程如下。

$$
d p[i]=\max _{1 \leq a<i}\{\max (a \times(i-a), a \times d p[i-a])\}
$$

### 最优解返回

最终，`dp[n]`就是我们求解的整数n分解的最大乘积。

因此我们可以很轻易写出本题的代码如下，也可以见于[solve.py](./solve.py)。

```python
class Solution:
    def integerBreak(self, n: int) -> int:
        dp = [0] * (n+1)
        for i in range(2, n+1):
            for j in range(i):
                dp[i] = max(j*(i-j), j*dp[i-j], dp[i])
        return dp[n]
```

最后不妨看看我们这个略显暴力的DP复杂度是怎么样的，显然，二重遍历对于数字n的复杂度为$O(n^2)$，而维护的dp数组带来的空间复杂度为$O(n)$。

## 优化思路（**借助数学**）

这题能否优化呢？显然，我们能优化的就是这个庞大的时间复杂度，这种二次方的复杂是由二重循环带来的，能否优化这个循环呢？

$$
d p[i]=\max _{1 \leq a<i}\{\max (a \times(i-a), a \times d p[i-a])\}
$$

从上述的状态转移方程我们知道，计算每个`dp[i]`的时候，a是从1遍历到了i-1的所有值，这里其实总感觉怪怪的，真的有必要吗？其实，我们遍历a的目的是为了找到最大的那个值，当a固定的时候，我们对决定`dp[i]`的两项分别考虑，即`a*(i-a)`和`a*dp[i-a]`。

首先考虑`a*dp[i-a]`，根据dp[i]的定义，可以知道对于任意的1<=a<i，有dp[i]>=a*dp[i-a]。

- 当a是奇数时，有 $a=\frac{a-1}{2}+\frac{a+1}{2}$, 因此 $d p[i] \geq \frac{a-1}{2} \times d p\left[i-\frac{a-1}{2}\right] \geq \frac{a-1}{2} \times \frac{a+1}{2} \times d p[i-a]$；

- 当a是偶数时，有 $a=\frac{a}{2}+\frac{a}{2}$, 因此 $d p[i] \geq \frac{a}{2} \times d p\left[i-\frac{a}{2}\right] \geq \frac{a}{2} \times \frac{a}{2} \times d p[i-a]$ 。

当a>=4时且a是奇数，则$\frac{a-1}{2} \times \frac{a+1}{2}>a$恒成立；若a>=4且a是偶数，则$\frac{a}{2} \times \frac{a}{2} \geq a$恒成立，并且只有a=4时取得等号。

上述过程可以发现，若a>=4那么必有`dp[a]>a`，当且仅当a=4时等号成立，也就是说，a>=4时一定可以将a拆分为两个正整数的和却这些拆分得到的正整数乘积大于等于a。同时，也可以得到，若a>=4，则`dp[i]>=a*dp[i-a]`只有当a=4时可能成立，又因为$d p[i] \geq 2 \times d p[i-2] \geq 2 \times(2 \times d p[i-4])=4 \times d p[i-4]$，因此去a=3计算得到的dp[i]一定不会小于取a=4计算得到的dp[i]，**换句话说，a>=4以上的情况是不需要考虑的**。

那么，a=1是否需要考虑呢，其实也不需要。因为若a=1，则$d p[i] \geq 1 \times d p[i-1]=d p[i-1]$，当i>=3时，dp[i-1]是将正整数 i-1 拆分成至少两个正整数的和之后，这些正整数的最大乘积，在拆分成的正整数中，任选一个数字加 1，则拆分成的正整数的和变成 i，且乘积一定大于dp[i−1]，因此必有dp[i]>dp[i−1]，即当 a=1时不可能得到最大的dp[i]的值。

**根据上述分析可知，计算dp[i] 的值只需要考虑a=2 和a=3的情况，不需要遍历从1到i−1的所有值。**

接着我们考虑`a*(i-a)`这一项，这里其实也可以证明依然只需要考虑a=2和3的情况，因此可以对此前的动态规划进行优化，得到i>=3时的状态转移方程如下。

$$
d p[i]=\max (2 \times(i-2), 2 \times d p[i-2], 3 \times(i-3), 3 \times d p[i-3])
$$

此时代码就更新如下。

```python
class Solution:
    def integerBreak(self, n: int) -> int:
        dp = [0] * (n+1)
        dp[2] = 1
        for i in range(3, n+1):
            dp[i] = max(2*(i-2), 2*dp[i-2], 3*(i-3), 3*dp[i-3])
        return dp[n]
```

显然，此时时间复杂度降到了$O(n)$，空间复杂度依然是$O(n)$。






