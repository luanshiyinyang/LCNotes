## 题目描述

给定一个链表，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 -1，则在该链表中没有环。注意：`pos` 不作为参数进行传递，仅仅是为了标识链表的实际情况。

如果链表中存在环，则返回 `true` 。 否则，返回 `false` 。

**进阶：**

你能用 O(1)（即，常量）内存解决此问题吗？

## 题解思路

有环链表的判断是很多面试常见的基础算法题，这道题是有环链表题中最基础的判断题。

我们首先来看一个非常常见的思路：**顺序遍历链表的所有节点，每次遍历一个节点，判断这个节点是否被访问过。** 节点是否被访问这个操作可以通过哈希表来实现，我们每次到达一个节点，判断是否其已经存在于哈希表中，若存在则说明该链表是环形链表，若不存在，则将其加入哈希表继续判断。重复这一过程直到遍历完整个链表。

这种思路的代码如下。

```python
class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        seen = set()
        while head:
            if head in seen:
                return True
            seen.add(head)
            head = head.next
        return False
```
这个解法的时间复杂度是$O(N)$且空间复杂度也是$O(N)$，这里的$N$是链表的节点数目。

显然，若是链表很长，这个空间消耗是非常恐怖的，因此我们可以看到题目中要求我们实现一个空间消耗$O(1)$版本的，我们下一节讲述。

## 优化思路

优化的思路源于经典的Floyd 判圈算法（也叫龟兔赛跑算法），简单说明一下。

> 若是两个人从同一地点起跑，一个运动员速度快一个速度慢。那么当跑道有环的时候，跑得快的一定会比跑得慢的先进入环内并在环内移动，等到跑的慢的进入环里面的时候，由于跑的快的那个人速度快，他一定会在某个时刻与跑的慢的相遇，即套了跑的慢的若干圈。若跑道没有环，显然两人永远不会相遇。

借用上面的思路，我们可以定义一快一慢两个指针，慢指针每次移动一步，快指针每次移动两步。一开始这两个指针都指向`head`，如果移动过程中快指针反过来追上了慢指针，那么一定存在环形链表，否则快的指针会到达链表尾部（链表无环）。

这个思路的实现代码如下，也可见于[solve.py](./solve.py)。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        p1, p2 = head, head;
        while p2 != None and p2.next != None:
            p1 = p1.next;
            p2 = p2.next.next;
            if p1 == p2:
                return True
        return False
```
显然，上述代码的时间复杂度还是$O(N)$，但是空间复杂度缩减为$O(1)$。
