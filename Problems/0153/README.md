## 题目描述

已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 旋转 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：

- 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]`
- 若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]`
  注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` 旋转一次 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。

## 题解思路

这道题很容易想到二分的解法，因为不论旋转多少次，最终得到的数组其实一定是局部有序的，更直白来说，其实是升序数组最后若干个值按顺序移动到了数组的最前端，这点是可以理解的。

![](https://s2.loli.net/2022/01/20/dDzxPZWSuK1TNVy.png)

用官方题解的可视化呈现如上，其中横轴表示数组元素的下标，纵轴表示数组元素的值。图中标出了最小值的位置，这就是我们需要查找的目标。

从图上不难看出，最小值其实分隔了两端升序子数组，我们的目标就是定位到这个最小值。那么我们如何才能利用二分缩小区间的方式来搜索呢？首先我们需要的就是区间如何缩短，也就是**区间边界如何更新的问题**。我们不妨记数组最后一个元素为x，那么显然有在最大值的右侧的元素均小于x，在最大值的左侧的元素均大于x，我们可以通过这个极值性质来更新二分中点。

具体算法为，记左边界为left，右边界为right，区间中点为mid，最小值必在该区间范围内，当区间范围缩小至1的时候，该区间内的唯一值就是最小值。

我们每次将区间中点值和右边界值进行比较，那么存在三种情况：
- 若`nums[mid] < nums[right]`，这说明mid在最小值的右侧，那么将right更新为mid即可缩小范围（因为right和mid之间可以直接忽略）；
- 若`nums[mid] > nums[right]`，这说明mid在最小值的左侧，那么将left更新为mid+1即可缩小范围（因为left和mid之间可以直接忽略）；
- 若`nums[mid] = nums[right]`，由于不存在重复元素，所以直到搜索结束，不会出现该情况。

代码如下，也可见于[solve.py](./solve.py)。

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        left, right = 0, len(nums) - 1
        while left < right:
            mid = (left + right) // 2
            if nums[mid] < nums[right]:
                right = mid
            else:
                left = mid + 1
        return nums[left]
```

显然，上述解法的时间复杂度为$O(logn)$，空间复杂度为$O(1)$。
