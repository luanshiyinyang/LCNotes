## 题目描述

给你一个任务数组`tasks`，其中`tasks[i] = [actual_i, minimum_i]`：

- `actual_i`表示完成第`i`个任务需要耗费的实际能力；
- `minimum_i`表示开始第`i`个任务需要达到的最低能量。

比方说，如果任务为`[10, 12]`且你的能量为11，那么你不能开始这个任务。如果你当前的能量为13，你可以完成这个任务，且完成它后的剩余能量为3。

你可以按照**任意顺序**完成任务，请返回完成所有任务**最少**的初始能量。

**示例1：**
```
输入：tasks = [[1,2],[2,4],[4,8]]
输出：8
解释：
一开始有 8 能量，我们按照如下顺序完成任务：
    - 完成第 3 个任务，剩余能量为 8 - 4 = 4 。
    - 完成第 2 个任务，剩余能量为 4 - 2 = 2 。
    - 完成第 1 个任务，剩余能量为 2 - 1 = 1 。
注意到尽管我们有能量剩余，但是如果一开始只有 7 能量是不能完成所有任务的，因为我们无法开始第 3 个任务。
```
**示例2：**
```
输入：tasks = [[1,3],[2,4],[10,11],[10,12],[8,9]]
输出：32
解释：
一开始有 32 能量，我们按照如下顺序完成任务：
    - 完成第 1 个任务，剩余能量为 32 - 1 = 31 。
    - 完成第 2 个任务，剩余能量为 31 - 2 = 29 。
    - 完成第 3 个任务，剩余能量为 29 - 10 = 19 。
    - 完成第 4 个任务，剩余能量为 19 - 10 = 9 。
    - 完成第 5 个任务，剩余能量为 9 - 8 = 1 。
```
**示例3：**
```
输入：tasks = [[1,7],[2,8],[3,9],[4,10],[5,11],[6,12]]
输出：27
解释：
一开始有 27 能量，我们按照如下顺序完成任务：
    - 完成第 5 个任务，剩余能量为 27 - 5 = 22 。
    - 完成第 2 个任务，剩余能量为 22 - 2 = 20 。
    - 完成第 3 个任务，剩余能量为 20 - 3 = 17 。
    - 完成第 1 个任务，剩余能量为 17 - 1 = 16 。
    - 完成第 4 个任务，剩余能量为 16 - 4 = 12 。
    - 完成第 6 个任务，剩余能量为 12 - 6 = 6 。
```

## 题解思路

最近遇到了类似的题目所以把这道题拿过来做一下，我们初看到这道题其实会产生一个最直接的想法，**按照某种顺序去完成task才能保证最优解，即最少初始能量**。

不妨记每个任务的两个属性为`[cost, threshold]`，前者表示该任务完成需要消耗的能量（代价，cost），后者则表示完成该任务需要持有最低能量（阈值，threshold）。

首先，我们有一个分析可以得到，**能量在做任务的过程中只会不断减少（被不同的任务消耗），因此最少能量至少是所有任务的cost的和。** 当然，不只是受到这个总和的限制，还受到每个任务的阈值的限制，因此我们需要找到一种排序的思路，那么如何得到这个思路呢？

> 这题的本质其实是贪心，已经有人给出了详细的[数学证明](https://leetcode-cn.com/problems/minimum-initial-energy-to-finish-tasks/solution/wan-cheng-suo-you-ren-wu-de-zui-shao-chu-shi-neng-/)，我就不班门弄斧了，但是贪心其实最难的就是想明白为什么，因此我们这里可以直观上做一个理解。

`threshold`表示的是“开始这个任务时，拥有的最少能量”，`cost`表示的是“完成这个任务需要消耗的能量”，那么有他们的差`threshold-cost`表示“完成任务之后，剩余能量的最少值”。**为了完成所有的任务，我们当然希望剩余能量越多越好，所以我们应该先完成剩余能量多的任务，也就是`threshold-cost`大的任务。** 进一步，如果`threshold-cost`一样，当然应该先完成`threshold`较大的任务，也就是先把能量阈值较大的任务完成（不然，随着任务的进行，能量越来越少，后面的任务就有可能无法完成了，不过，数学上看，这个第二步是没有必要的）。

因此，排序之后，我们只需要遍历所有任务，每次累加上`当前需要的cost加累计需要的能量的和`与`当前阈值`的较大者即可。

代码如下，也可见于[solve.py](./solve.py)。

```python
class Solution:
    def minimumEffort(self, tasks: List[List[int]]) -> int:
        tasks.sort(key=lambda x: (x[1] - x[0]))
        res = 0
        for cost, threshold in tasks:
            res = max(res + cost, threshold)
        return res
```



