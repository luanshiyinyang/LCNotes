## 题目描述

给你两个单词`word1`和`word2`，请你计算出将`word1`转换成`word2`所使用的最少操作数。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

**示例1：**
```
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

**示例2：**
```
输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
```


## 题解思路

这题的难度是Hard，为什么它这么难呢？没有为什么，它就是难，难得让人觉得手足无措（**如果你看到这里不妨回头再看看题目，有没有一丝丝的想法**）。本题的官方题解给出了一个最优的动态规划解法，并做了详细的推导，**但是我们其实很难一下子想到这一步。**

那么这题我们应该怎么想呢？这道题目其实是编辑距离类的最经典的题目，题名就是"编辑距离"。首先我们应该先想到，两个字符串的动态规划问题一般都是使用两个指针i和j指向两个字符串的最后，然后一步步往前走缩小问题的规模。（**注意，此时我们也许并不知道怎么用动态规划解，但我们应有这种直觉**）

那么这道题，我们用两个指针进行指向应该怎么考虑呢？很简单，对于字符串`word1`和字符串`word2`，当两个指针访问到`word1[i]`和`word2[j]`的时候，有下面四种操作：

- 若`word1[i] == word2[j]`，则什么都不做，且i和j同时前移；
- 若不满足上述情况，则在插入、删除和替换操作间选择一个即可。至于选择哪个，很简单，都试一遍，哪个得到的编辑距离最小，就用哪个。

这里可以定义一个递归函数dp(i,j)表示求解`word[0:i]`与`word[0:j]`的最短编辑距离，那么我们可以得到下面的代码。

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        def dp(i, j):
            if i == -1:
                return j + 1
            if j == -1:
                return i + 1
            if word1[i] == word2[j]:
                return dp(i-1, j-1)  # 不进行操作
            else:
                return min(
                    dp(i, j-1) + 1,  # 插入
                    dp(i-1, j) + 1,  # 删除
                    dp(i-1, j-1) + 1  # 替换
                )
        return dp(len(word1)-1, len(word2)-1)
```

我们来理解一下三种操作，若要进行插入，则可以在`word1[i]`处插入一个和`word2[j]`一样的字符，此时`word2[j]`就匹配上，j前移，操作数加1；若要进行删除，则直接将`word1[i]`删除，此时i前移和j继续比对，操作数加一；至于替换操作，那就更简单了，直接将`word1[i]`替换为`word2[j]`，他俩就匹配上了，同时前移i和j，操作数加1。

至此，你应该完全理解了这段看起来**简单**的代码，这里都是优先对word1操作的，这是因为word1变为word2和word2变为word1的最短编辑距离一定是一样的，我们选择其一即可。遗憾的是，这其实是一种非常暴力的解法，存在大量的重叠子问题，因此需要使用动态规划来优化，使用这种递归的方法提交会出现TLE错误。

## 优化思路

上面这种递归的解法为什么会存在重叠子问题呢，其实我们不妨对其进行一个抽象。

$dp(i, j)$有三个由来，分别是：

- 式1 $dp(i-1,j-1)$
- 式2 $dp(i,j-1)$
- 式3 $dp(i-1,j)$

那么考虑$dp(i-1,j-1)$这个子问题，如何通过原问题$dp(i,j)$得到呢？很显然，我们可以通过式1直接得到，也可以通过式2->式3的顺序得到，这显然是一个重复的路径。一旦存在一条重复路径，就一定存在大量的重复路径，也就是存在重叠子问题。

下面我们来看如何通过动态规划来进行优化。**其实，所谓动态规划，就是一种高效利用已有的解求解未知解的技术。** 因为要利用已经求解的结果，因此我们需要维护一个dp数组来存储最优解，有了上面递归的铺垫，其实不难设计这个二维dp数组，不过由于数组的索引下界是0，因此我们用`dp[i-1][j-1]`表示`word1[0:i]`和`word2[0:j]`的最小编辑距离。

由于思路类似，我们直接套用上面的递归写法即可，不过，动态规划是自底向上求解，而递归是自顶向下求解的。因此，如下代码所示，也可见于[solve.py](./solve.py)。

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        n, m = len(word1), len(word2)
        dp = [[0] * (m+1) for i in range(n+1)]
        # 初始化边界情况
        for i in range(n+1):
            dp[i][0] = i
        for j in range(m+1):
            dp[0][j] = j
        # 递推所有解
        for i in range(1, n+1):
            for j in range(1, m+1):
                if word1[i-1] == word2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = min(
                        dp[i][j-1] + 1,
                        dp[i-1][j] + 1,
                        dp[i-1][j-1] + 1
                    )
        return dp[n][m]
```

上述解法平台上提交是不会出现TLE超时错误的，它的时间空间复杂度均为$O(MN)$，其中$M$和$N$分别为两个字符串的长度。
