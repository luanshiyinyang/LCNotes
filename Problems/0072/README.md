## 题目描述

给你两个单词`word1`和`word2`，请你计算出将`word1`转换成`word2`所使用的最少操作数。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

**示例1：**
```
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

**示例2：**
```
输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
```


## 题解思路

这题的难度是Hard，为什么它这么难呢？没有为什么，它就是难，难得让人觉得手足无措（**如果你看到这里不妨回头再看看题目，有没有一丝丝的想法**）。本题的官方题解给出了一个最优的动态规划解法，并做了详细的推导，**但是我们其实很难一下子想到这一步。**

那么这题我们应该怎么想呢？这道题目其实是编辑距离类的最经典的题目，题名就是"编辑距离"。首先我们应该先想到，两个字符串的动态规划问题一般都是使用两个指针i和j指向两个字符串的最后，然后一步步往前走缩小问题的规模。（**注意，此时我们也许并不知道怎么用动态规划解，但我们应有这种直觉**）

那么这道题，我们用两个指针进行指向应该怎么考虑呢？很简单，对于字符串`word1`和字符串`word2`，当两个指针访问到`word1[i]`和`word2[j]`的时候，有下面四种操作：

- 若`word1[i] == word2[j]`，则什么都不做，且i和j同时前移；
- 若不满足上述情况，则在插入、删除和替换操作间选择一个即可。至于选择哪个，很简单，都试一遍，哪个得到的编辑距离最小，就用哪个。

这里可以定义一个递归函数dp(i,j)表示求解`word[0:i]`与`word[0:j]`的最短编辑距离，那么我们可以得到下面的代码。

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        def dp(i, j):
            if i == -1:
                return j + 1
            if j == -1:
                return i + 1
            if word1[i] == word2[j]:
                return dp(i-1, j-1)  # 不进行操作
            else:
                return min(
                    dp(i, j-1) + 1,  # 插入
                    dp(i-1, j) + 1,  # 删除
                    dp(i-1, j-1) + 1  # 替换
                )
        return dp(len(word1)-1, len(word2)-1)
```

我们来理解一下三种操作，若要进行插入，则可以在`word1[i]`处插入一个和`word2[j]`一样的字符，此时`word2[j]`就匹配上，j前移，操作数加1；若要进行删除，则直接将`word1[i]`删除，此时i前移和j继续比对，操作数加一；至于替换操作，那就更简单了，直接将`word1[i]`替换为`word2[j]`，他俩就匹配上了，同时前移i和j，操作数加1。

至此，你应该完全理解了这段看起来**简单**的代码，这里都是优先对word1操作的，这是因为word1变为word2和word2变为word1的最短编辑距离一定是一样的，我们选择其一即可。遗憾的是，这其实是一种非常暴力的解法，存在大量的重叠子问题，因此需要使用动态规划来优化，使用这种递归的方法提交会出现TLE错误。

## 优化思路

下面我们来看优化的思路。
