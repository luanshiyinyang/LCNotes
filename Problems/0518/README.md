## 题目描述

给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 `32` 位带符号整数。

**示例 1：**

```
输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```

**示例 2：**

```
输入：amount = 3, coins = [2]
输出：0
解释：只用面额 2 的硬币不能凑成总金额 3 。
```

**示例 3：**

```
输入：amount = 10, coins = [10] 
输出：1
```

## 题解思路

N个不同面额的硬币和总金额是典型的背包问题，本题不限制硬币的使用次数，因此是一个完全背包问题。需要注意的是，本题求解的是组合数而不是排列数，也就是说`2+1+2`和`2+2+1`是一个方案，因此本题需要注意外层循环遍历物品而不是背包容量。

我们直接采用完全背包的模板，使用一维dp数组来解，**定义**`dp[j]`表示凑成总金额j的硬币组合数。dp数组的**初始化**需要注意，`dp[0]=1`，也就是说凑成总金额为0的组合数为1，即什么也不选。递推时，遍历硬币数组，对每种硬币coins[i]：
- 若`j<coins[i]`，则在选取的数字的和等于j的情况下无法渠道当前数字`coins[i]`，因此有`dp[j]=dp[j]`。
- 若`j>=coins[i]`，则对于当前的数字`coins[i]`，可选可不选。如果选，那么`dp[j]=dp[j-coins[i]]`；如果不选，那么`dp[j]=dp[j]`。

具体的代码如下，也可见于[solve.py](./solve.py)。

```python
class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        dp = [0] * (amount + 1)
        dp[0] = 1
        for coin in coins:
            for i in range(coin, amount + 1):
                dp[i] += dp[i-coin]
        return dp[amount]
```

上述解法的时间复杂度为$O(amount \times n)$，其中amount 是总金额，n 是数组coins 的长度。空间复杂度为$O(amount)$，其中amount是总金额。