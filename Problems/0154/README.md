## 题目描述

已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 旋转 后，得到输入数组。例如，原数组 `nums = [0,1,4,4,5,6,7]` 在变化后可能得到：

- 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,4]`
- 若旋转 `7` 次，则可以得到 `[0,1,4,4,5,6,7]`

注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` 旋转一次 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

给你一个可能存在 **重复** 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。

## 题解思路

这题和上一题[153 寻找旋转排序数组中的最小值](../0153/README.md)非常类似，只不过，**旋转数组的元素存在重复值**了。考虑到数组局部有序的性质，我们还是希望通过二分的思路来求解本题，但是，本题之所以难度为 Hard，就在于边界更新有所不同。

我们依然以官方绘图为例，展开说明。

![](https://s2.loli.net/2022/01/21/3hVGspXob26Hfai.png)

显然，我们考虑数组中的最后一个元素 x：在最小值右侧的元素，它们的值一定都小于等于 x；而在最小值左侧的元素，它们的值一定都大于等于 x。因此，我们可以根据这一条性质，通过类似上一题的二分查找的方法找出最小值。

不妨定义左界为 left，右界限为 right，区间中点为 mid，最小值必在次区间内，每次比较中点元素`nums[mid]`和右界元素`nums[right]`，则存在下面三种情况。

- 若`nums[mid] < nums[right]`，那么最小值一定在 mid 的左侧，所以忽略 mid 右侧的区域，即`right=mid`；
- 若`nums[mid] > nums[right]`，那么最小值一定在 mid 的右侧，所以忽略 mid 左侧的区域，即`left=mid+1`；
- 若`nums[mid] = nums[right]`，此时是一种比较麻烦的情况，因为存在重复值，所以无法判定 mid 是在最小值的左侧还是右侧（如下图），但是，由于这两个值一样，因此 right 位置的值必定可以用 mid 取代，因此 right 可以左移一位，即`right=right-1`。

![](https://s2.loli.net/2022/01/21/VHfxOEi3znmPtLo.png)

代码如下，也可见于[solve.py](./solve.py)。

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        left, right = 0, len(nums) - 1
        while left < right:
            mid = (left + right) // 2
            if nums[mid] < nums[right]:
                right = mid
            elif nums[mid] > nums[right]:
                left = mid + 1
            else:
                right -= 1
            
        return nums[left]
```

上述解法的空间复杂度为$O(1)$，这没什么疑问。关于时间复杂度，平均时间复杂度为$O(logn)$，其中 $n$ 是数组 nums 的长度。如果数组是随机生成的，那么数组中包含相同元素的概率很低，在二分查找的过程中，大部分情况都会忽略一半的区间。而在最坏情况下，如果数组中的元素完全相同，那么循环就需要执行 n 次，每次忽略区间的右端点，时间复杂度为 $O(n)$。
