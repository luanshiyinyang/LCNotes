## 题目描述

给你一个字符串 s 和一个字符串数组 dictionary 作为字典，找出并返回字典中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。

如果答案不止一个，返回长度最长且字典序最小的字符串。如果答案不存在，则返回空字符串。

**示例 1：**
```
输入：s = "abpcplea", dictionary = ["ale","apple","monkey","plea"]
输出："apple"
```
**示例 2：**
```
输入：s = "abpcplea", dictionary = ["a","b","c"]
输出："a"
```

## 题解思路

这道题字典的元素之间没有任何关系，因此，可以分两步来解决问题。第一步，判断字典元素是否可以通过删除给定字符串 s 中某些字符得到。也就是说，s 中包含字典元素的所有字符且字符的顺序也相同，s 中匹配到的第一个字符即为最优决策，可联想到双指针解法。设两个指针 i、j 分别对应字典元素和 s 的首项，对比 i 和 j 的值，若相等，则都指向下一个字符，匹配下一个相等的字符，否则，j 指向下一个字符，继续寻找匹配 i 的字符，直到 i 移动到字典元素的末项。第二步，找到长度最长且字典序最小的符合的字典元素，可先将字典进行排序，减少需要遍历的字典元素。时间复杂度为$O(d*(m+n))$，空间复杂度为$O(d*m)$，其中，d 为字典的长度，m 为字典元素的长度，n 为 s 的长度。

代码如下，也可见 [solve.ts](./solve.ts)。

```typescript
const findLongestWord = (s: string, dictionary: string[]): string => {
  dictionary.sort((a, b) => a.length - b.length || b.localeCompare(a))
  for (let i = dictionary.length - 1; i >= 0; i--) {
    let m = 0
    let n = 0
    while (m < s.length) {
      if (s[m] == dictionary[i][n]) n++
      if (n == dictionary[i].length) return dictionary[i]
      m++
    }
  }
  return ''
}

```

## 优化思路

做完看了看题解，发现可以用动态规划优化。这里直接照搬了官方的题解，哪天心情好了再来改。

> 在方法一的基础上，我们考虑通过对字符串 s 的预处理，来优化第 1 个问题的处理。考虑前面的双指针的做法，我们注意到我们有大量的时间用于在 s 中找到下一个匹配字符。这样我们通过预处理，得到：对于 s 的每一个位置，从该位置开始往后每一个字符第一次出现的位置。我们可以使用动态规划的方法实现预处理，令 $f[i][j]$ 表示字符串 s 中从位置 i 开始往后字符 j 第一次出现的位置。在进行状态转移时，如果 s 中位置 i 的字符就是 j，那么 $f[i][j]=i$，否则 j 出现在位置 i+1 开始往后，即 $f[i][j]=f[i+1][j]$；因此我们要倒过来进行动态规划，从后往前枚举 i。这样我们可以写出状态转移方程：<br>
$f[i][j]= \begin{cases} i, & s[i]=j \\ f[i+1][j], & s[i] \ne j \end{cases}$<br>
假定下标从 0 开始，那么 $f[i][j]$ 中有$0 \leq i \leq m-1$，对于边界状态 $f[m-1][..]$，我们置 $f[m][..]$ 为 m，让 $f[m-1][..]$ 正常进行转移。这样如果 $f[i][j]=m$，则表示从位置 i 开始往后不存在字符 j。这样，我们可以利用 $f$ 数组，每次 $O(1)$ 地跳转到下一个位置，直到位置变为 m 或 t 中的每一个字符都匹配成功。
