## 题目描述

给定n和k，以及包含n个元素的数组a，要求将其切分为k个非空子数组，其中1<=k<=n<=300000，每个元素ai为整数，且|ai|<=1000000。设f(i)为第i个元素所属的子数组号，子数组编号从1到k，定义$score=\sum(ai \times f(i))$，求出使得score最大的k段切分方法，输出该score。

下面是测试样例。
```
n = 5, k = 2
a = [-1, -2, 5, -4, 8]
max_score = 15
```

```
n = 7, k = 6
a = [-3, 0, -1, -2, -2, -4, -1]
max_score = -45
```

```
n = 4, k = 1
a = [3, -1, 6, 0]
max_score = 8
```

```
n = 5, k = 2
a = [1, 2, 3, 4, 5]
max_score = 29
```

## 题解思路

本题和[Leetcode 410](https://github.com/luanshiyinyang/LCNotes/blob/main/Problems/0410/README.md)题很类似，但是解法却相差很大，因为本体数组没有非负的限制。刚拿到这题会想到动态规划，但是使用动态规划的思路会感觉无从下手（反正我没推出来，加上时间有限就转换思路了，**还有就是暴力遍历想都不要想，不可能的**）。

本体的核心思路在于要**将一个数和组号相乘（f(i)\*ai）理解为对这个数进行了组号（f(i)）次加法**。例如我们对`[1,2,3,4,5]`划分为3段`[[1],[2,3],[4,5]]`，我们按照题意计算score，将过程拆解**如下图**，可以发现第一段出现一次，第二段出现两次，以此类推，不难发现，**所谓的划分k段求score其实就是k个以最后一个元素为右端，以数组中任意一个元素为左端的子数组的和，且每个子数组左端不能重复**。

![](https://i.loli.net/2021/08/27/7O21wfTGJHXqnWN.png)

因此上述问题被“轻易😁”转化为了后缀和问题，不过，由于实际上是从前面向后取得，因此第一个到最后一个这样的子数组（也就是原始数组）必须取到，因此实际上是整个数组加上k-1个后缀子数组的和。

理解了上面，思路就非常简单了，从后向前计算每个后缀子数组的和并排序得出最大的k-1个并将其和原始数组的和相加即可。



下面是完整的代码，也可见于[solve.py](./solve.py)。
```python
class Solution(object):
    def solve(self, n: int, k: int, a: list):
        accu = [a[-1]]
        # 累加后缀和
        for i in range(1, n):
            accu.append(accu[i - 1] + a[-(i + 1)])
        ans = accu[-1]  # 必有原始数组
        accu.pop(-1)
        accu.sort(reverse=True)  # 降序排列
        ans += sum(accu[:(k - 1)])  # 原始数组加上最大的k-1个后缀和
        return ans
```

